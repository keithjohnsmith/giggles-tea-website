require('dotenv').config();
const express = require('express');
const cors = require('cors');
const bodyParser = require('body-parser');
const path = require('path');
const connectDB = require('./config/db');
const { generateToken, authenticateJWT } = require('./auth');

// Import routes
const productRoutes = require('./routes/productRoutes');
const orderRoutes = require('./routes/orderRoutes');

// Connect to MongoDB
connectDB();

const app = express();
const PORT = process.env.PORT || 5000;

// Middleware
app.use(cors());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(bodyParser.urlencoded({ extended: true }));

// API Routes
app.use('/api/products', productRoutes);
app.use('/api/orders', orderRoutes);

// Serve static assets in production
if (process.env.NODE_ENV === 'production') {
  // Set static folder
  app.use(express.static(path.join(__dirname, '../client/build')));

  app.get('*', (req, res) => {
    res.sendFile(path.resolve(__dirname, '../client', 'build', 'index.html'));
  });
}

// Middleware
app.use(cors());
app.use(bodyParser.json());

// Authentication routes
app.post('/api/auth/register', async (req, res) => {
  const { username, email, password } = req.body;
  
  try {
    // Check if user already exists
    const userExists = await User.findOne({ email });
    if (userExists) {
      return res.status(400).json({ error: 'User already exists' });
    }

    // Create new user
    const user = await User.create({
      username,
      email,
      password // The pre-save hook will hash the password
    });

    // Generate token
    const token = generateToken({
      id: user._id,
      username: user.username,
      email: user.email,
      role: user.role
    });

    res.status(201).json({
      _id: user._id,
      username: user.username,
      email: user.email,
      role: user.role,
      token
    });
  } catch (error) {
    console.error('Registration error:', error);
    res.status(500).json({ error: 'Server error during registration' });
  }
});

app.post('/api/auth/login', async (req, res) => {
  const { email, password } = req.body;
  
  try {
    // Find user by email
    const user = await User.findOne({ email });
    
    if (!user) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }
    
    // Check password
    const isMatch = await user.matchPassword(password);
    if (!isMatch) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    // Generate token
    const token = generateToken({
      id: user._id,
      username: user.username,
      email: user.email,
      role: user.role
    });

    res.json({
      _id: user._id,
      username: user.username,
      email: user.email,
      role: user.role,
      token
    });
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ error: 'Server error during login' });
  }
});

// Protected route example
app.get('/api/auth/me', authenticateJWT, async (req, res) => {
  try {
    const user = await User.findById(req.user.id).select('-password');
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }
    res.json(user);
  } catch (error) {
    console.error('Get user error:', error);
    res.status(500).json({ error: 'Server error' });
  }
});

// Admin routes
app.get('/api/admin/users', authenticateJWT, async (req, res) => {
  try {
    if (req.user.role !== 'admin') {
      return res.status(403).json({ error: 'Not authorized as admin' });
    }

    const users = await User.find({}).select('-password');
    res.json(users);
  } catch (error) {
    console.error('Get users error:', error);
    res.status(500).json({ error: 'Server error' });
  }
});

app.post('/api/admin/users', authenticateJWT, async (req, res) => {
  try {
    if (req.user.role !== 'admin') {
      return res.status(403).json({ error: 'Not authorized as admin' });
    }

    const { username, email, password, role = 'user' } = req.body;
    
    if (!username || !email || !password) {
      return res.status(400).json({ error: 'Username, email, and password are required' });
    }

    const userExists = await User.findOne({ $or: [{ email }, { username }] });
    if (userExists) {
      return res.status(400).json({ error: 'User already exists with this email or username' });
    }

    const user = await User.create({
      username,
      email,
      password,
      role
    });

    res.status(201).json({
      _id: user._id,
      username: user.username,
      email: user.email,
      role: user.role,
      createdAt: user.createdAt
    });
  } catch (error) {
    console.error('Create user error:', error);
    res.status(500).json({ error: 'Server error creating user' });
  }
});

// Update user
app.put('/api/admin/users/:id', authenticateJWT, async (req, res) => {
  try {
    if (req.user.role !== 'admin') {
      return res.status(403).json({ error: 'Not authorized as admin' });
    }

    const { username, email, role } = req.body;
    const userId = req.params.id;

    const user = await User.findById(userId);
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }

    // Prevent modifying the last admin
    if (user.role === 'admin' && req.user.id !== user.id) {
      const adminCount = await User.countDocuments({ role: 'admin' });
      if (adminCount <= 1) {
        return res.status(400).json({ error: 'Cannot modify the last admin' });
      }
    }

    user.username = username || user.username;
    user.email = email || user.email;
    if (role) user.role = role;
    user.updatedAt = Date.now();

    const updatedUser = await user.save();
    
    res.json({
      _id: updatedUser._id,
      username: updatedUser.username,
      email: updatedUser.email,
      role: updatedUser.role,
      updatedAt: updatedUser.updatedAt
    });
  } catch (error) {
    console.error('Update user error:', error);
    res.status(500).json({ error: 'Server error updating user' });
  }
});

// Delete user
app.delete('/api/admin/users/:id', authenticateJWT, async (req, res) => {
  try {
    if (req.user.role !== 'admin') {
      return res.status(403).json({ error: 'Not authorized as admin' });
    }

    const userId = req.params.id;
    
    // Prevent deleting yourself
    if (req.user.id === userId) {
      return res.status(400).json({ error: 'Cannot delete your own account' });
    }

    const user = await User.findById(userId);
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }

    // Prevent deleting the last admin
    if (user.role === 'admin') {
      const adminCount = await User.countDocuments({ role: 'admin' });
      if (adminCount <= 1) {
        return res.status(400).json({ error: 'Cannot delete the last admin' });
      }
    }

    await User.deleteOne({ _id: userId });
    res.json({ message: 'User removed' });
  } catch (error) {
    console.error('Delete user error:', error);
    res.status(500).json({ error: 'Server error deleting user' });
  }
});

// Start server
const server = app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});

// Handle unhandled promise rejections
process.on('unhandledRejection', (err) => {
  console.error('Unhandled Rejection:', err);
  server.close(() => process.exit(1));
});
    if (!isMatch) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }
    
    const userData = {
      id: user.id,
      username: user.username,
      email: user.email,
      role: user.role
    };
    
    const token = generateToken(userData);
    res.json({ user: userData, token });
  });
});

// Protected route example
app.get('/api/me', authenticateJWT, (req, res) => {
  res.json({ user: req.user });
});

// Admin routes - protected by JWT and require admin role
app.use('/api/admin', authenticateJWT, requireAdmin);

// Admin product management
app.post('/api/admin/products', (req, res) => {
  const { name, description, price, stock, category_id, image_url } = req.body;
  
  db.run(
    'INSERT INTO products (name, description, price, stock, category_id, image_url) VALUES (?, ?, ?, ?, ?, ?)',
    [name, description, price, stock, category_id, image_url],
    function(err) {
      if (err) {
        return res.status(400).json({ error: err.message });
      }
      
      db.get('SELECT * FROM products WHERE id = ?', [this.lastID], (err, product) => {
        if (err) {
          return res.status(500).json({ error: 'Error retrieving product' });
        }
        res.status(201).json(product);
      });
    }
  );
});

app.put('/api/admin/products/:id', (req, res) => {
  const { name, description, price, stock, category_id, image_url } = req.body;
  
  db.run(
    'UPDATE products SET name = ?, description = ?, price = ?, stock = ?, category_id = ?, image_url = ? WHERE id = ?',
    [name, description, price, stock, category_id, image_url, req.params.id],
    function(err) {
      if (err) {
        return res.status(400).json({ error: err.message });
      }
      
      db.get('SELECT * FROM products WHERE id = ?', [req.params.id], (err, product) => {
        if (err || !product) {
          return res.status(404).json({ error: 'Product not found' });
        }
        res.json(product);
      });
    }
  );
});

app.delete('/api/admin/products/:id', (req, res) => {
  db.run('DELETE FROM products WHERE id = ?', [req.params.id], function(err) {
    if (err) {
      return res.status(400).json({ error: err.message });
    }
    
    if (this.changes === 0) {
      return res.status(404).json({ error: 'Product not found' });
    }
    
    res.json({ message: 'Product deleted successfully' });
  });
});

// Admin user management routes
app.get('/api/admin/users', (req, res) => {
  db.all(
    'SELECT id, username, email, role, created_at, updated_at FROM users',
    [],
    (err, users) => {
      if (err) {
        return res.status(500).json({ error: err.message });
      }
      res.json(users);
    }
  );
});

app.post('/api/admin/users', async (req, res) => {
  const { username, email, password, role = 'user' } = req.body;
  
  if (!username || !email || !password) {
    return res.status(400).json({ error: 'Username, email, and password are required' });
  }
  
  try {
    const hashedPassword = await hashPassword(password);
    
    db.run(
      'INSERT INTO users (username, email, password, role) VALUES (?, ?, ?, ?)',
      [username, email, hashedPassword, role],
      function(err) {
        if (err) {
          if (err.message.includes('UNIQUE constraint failed: users.email')) {
            return res.status(400).json({ error: 'Email already in use' });
          }
          if (err.message.includes('UNIQUE constraint failed: users.username')) {
            return res.status(400).json({ error: 'Username already in use' });
          }
          return res.status(400).json({ error: err.message });
        }
        
        db.get(
          'SELECT id, username, email, role, created_at, updated_at FROM users WHERE id = ?',
          [this.lastID],
          (err, user) => {
            if (err) {
              return res.status(500).json({ error: 'Error retrieving user' });
            }
            res.status(201).json(user);
          }
        );
      }
    );
  } catch (error) {
    res.status(500).json({ error: 'Error creating user' });
  }
});

app.put('/api/admin/users/:id', async (req, res) => {
  const { username, email, password, role } = req.body;
  const userId = req.params.id;
  
  if (!username || !email) {
    return res.status(400).json({ error: 'Username and email are required' });
  }
  
  try {
    if (password) {
      const hashedPassword = await hashPassword(password);
      db.run(
        'UPDATE users SET username = ?, email = ?, password = ?, role = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?',
        [username, email, hashedPassword, role, userId],
        function(err) {
          handleUserUpdateResponse(err, userId, res);
        }
      );
    } else {
      db.run(
        'UPDATE users SET username = ?, email = ?, role = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?',
        [username, email, role, userId],
        function(err) {
          handleUserUpdateResponse(err, userId, res);
        }
      );
    }
  } catch (error) {
    res.status(500).json({ error: 'Error updating user' });
  }
});

function handleUserUpdateResponse(err, userId, res) {
  if (err) {
    if (err.message.includes('UNIQUE constraint failed: users.email')) {
      return res.status(400).json({ error: 'Email already in use' });
    }
    if (err.message.includes('UNIQUE constraint failed: users.username')) {
      return res.status(400).json({ error: 'Username already in use' });
    }
    return res.status(400).json({ error: err.message });
  }
  
  db.get(
    'SELECT id, username, email, role, created_at, updated_at FROM users WHERE id = ?',
    [userId],
    (err, user) => {
      if (err || !user) {
        return res.status(404).json({ error: 'User not found' });
      }
      res.json(user);
    }
  );
}

app.delete('/api/admin/users/:id', (req, res) => {
  const userId = req.params.id;
  
  // Prevent deleting the last admin
  db.get('SELECT COUNT(*) as adminCount FROM users WHERE role = ?', ['admin'], (err, result) => {
    if (err) {
      return res.status(500).json({ error: 'Error checking admin users' });
    }
    
    if (result.adminCount <= 1) {
      return res.status(400).json({ error: 'Cannot delete the last admin user' });
    }
    
    db.run('DELETE FROM users WHERE id = ?', [userId], function(err) {
      if (err) {
        return res.status(500).json({ error: err.message });
      }
      
      if (this.changes === 0) {
        return res.status(404).json({ error: 'User not found' });
      }
      
      res.json({ message: 'User deleted successfully' });
    });
  });
});

// Public products routes
app.get('/api/products', (req, res) => {
  const sql = 'SELECT * FROM products';
  db.all(sql, [], (err, rows) => {
    if (err) {
      res.status(400).json({ error: err.message });
      return;
    }
    res.json(rows);
  });
});

app.get('/api/products/:id', (req, res) => {
  const sql = 'SELECT * FROM products WHERE id = ?';
  db.get(sql, [req.params.id], (err, row) => {
    if (err) {
      res.status(400).json({ error: err.message });
      return;
    }
    res.json(row);
  });
});

// Categories routes
app.get('/api/categories', (req, res) => {
  const sql = 'SELECT * FROM categories';
  db.all(sql, [], (err, rows) => {
    if (err) {
      res.status(400).json({ error: err.message });
      return;
    }
    res.json(rows);
  });
});

// Orders routes
app.post('/api/orders', (req, res) => {
  const { customer_name, customer_email, customer_phone, shipping_address, items, total_amount } = req.body;
  
  db.serialize(() => {
    db.run(
      'INSERT INTO orders (customer_name, customer_email, customer_phone, shipping_address, total_amount) VALUES (?, ?, ?, ?, ?)',
      [customer_name, customer_email, customer_phone, shipping_address, total_amount],
      function(err) {
        if (err) {
          return res.status(400).json({ error: err.message });
        }
        
        const orderId = this.lastID;
        const stmt = db.prepare('INSERT INTO order_items (order_id, product_id, quantity, price) VALUES (?, ?, ?, ?)');
        
        items.forEach(item => {
          stmt.run(orderId, item.product_id, item.quantity, item.price);
        });
        
        stmt.finalize();
        res.json({ message: 'Order created successfully', orderId });
      }
    );
  });
});

// Start server
const server = app.listen(PORT, '0.0.0.0', () => {
  console.log(`Server running on http://localhost:${PORT}`);
  console.log(`Server running on http://${require('os').hostname()}:${PORT}`);
  console.log(`Server running on http://${require('os').networkInterfaces().Ethernet?.find(i => i.family === 'IPv4')?.address || '127.0.0.1'}:${PORT}`);
});

// Handle server errors
server.on('error', (error) => {
  if (error.code === 'EADDRINUSE') {
    console.error(`Port ${PORT} is already in use. Please stop the other process or use a different port.`);
  } else {
    console.error('Server error:', error);
  }
  process.exit(1);
});
